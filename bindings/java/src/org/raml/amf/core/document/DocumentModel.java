package org.raml.amf.core.document;

/**
 * Created by antoniogarrote on 04/05/2017.
 */

import api_modeling_framework.model.document.ParsedDocument;
import api_modeling_framework.model.document.ParsedFragment;
import api_modeling_framework.model.document.ParsedModule;
import clojure.lang.IFn;
import org.raml.amf.core.domain.DomainModel;
import org.raml.amf.core.exceptions.InvalidModelException;
import org.raml.amf.core.Model;
import org.raml.amf.core.exceptions.ResolutionException;
import org.raml.amf.core.exceptions.UnknownModelReferenceException;
import org.raml.amf.utils.Clojure;

import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.Objects;
import java.util.Optional;

/**
 * AMF Document model that can be used to work with the graph of linked documents generated by the parser.
 */
public abstract class DocumentModel extends Model {

    static {
        Clojure.require(Clojure.API_MODELING_FRAMEWORK_CORE);
        Clojure.require(Clojure.API_MODELING_FRAMEWORK_MODEL_DOCUMENT);
        Clojure.require(Clojure.API_MODELING_FRAMEWORK_MODEL_DOMAIN);
    }

    DocumentModel(Object rawModel) throws InvalidModelException {
        super(rawModel);
    }

    private boolean resolved = false;

    /**
     * Builds a new Model object for the referenced Document
     * @param reference
     * @return
     * @throws MalformedURLException
     * @throws InvalidModelException
     * @throws UnknownModelReferenceException
     */
    public DocumentModel modelForReference(URL reference) throws MalformedURLException, InvalidModelException, UnknownModelReferenceException {
        IFn referenceModelFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "reference-model");
        URL[] refs = this.references();
        for(URL ref : refs) {
            if (ref.sameFile(reference)) {
                return DocumentModel.fromRawModel(referenceModelFn.invoke(this.rawModel, ref.toString().replace("file:","")));
            }
        }

        throw new UnknownModelReferenceException(reference);
    }


    /**
     * Returns the list document URIs referenced from the document that has been parsed to generate this model
     * @return An array of URI locations for the remote documents
     */
    public URL[] references() throws MalformedURLException {
        IFn referencesFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "references");
        List<String> references = (List<String>) referencesFn.invoke(this.rawModel);
        URL[] acc = new URL[references.size()];
        for (int i=0; i<references.size(); i++) {
            String location = references.get(i);
            acc[i] = stringToURL(location);
        }

        return acc;
    }

    /**
     * Applies the resolution algorithm and returns a new Model contained the resolved DomainModel
     * @return
     */
    public DocumentModel resolve() throws ResolutionException {
        try {
            IFn domainModelFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "domain-model");
            IFn toModelFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "to-model");
            Object model = domainModelFn.invoke(this.rawModel);
            DocumentModel computed = null;
            if (model instanceof ParsedDocument) {
                computed = new Document(toModelFn.invoke(model));
            } else if (model instanceof ParsedModule) {
                computed = new Module(toModelFn.invoke(model));
            } else if (model instanceof ParsedFragment) {
                computed = new Fragment(toModelFn.invoke(model));
            }
            if (computed != null) {
                computed.setResolved(true);
            }
            return computed;
        } catch (Exception ex) {
            throw new ResolutionException(this, ex);
        }
    }

    /**
     * Returns the file location for the document that has been parsed to generate this model
     * @return URL with the location of the file
     */
    public URL location() throws MalformedURLException {
        IFn locationFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "location");
        String location = (String) locationFn.invoke(this.rawModel);
        return stringToURL(location);
    }


    /**
     * Returns the raw text of the parsed file for the file parsed to generate the model
     * @return Raw text
     */
    public Optional<String> rawText() {
        IFn rawFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "raw");
        String text = (String) rawFn.invoke(this.rawModel);
        if (text != null) {
            return Optional.of(text);
        } else {
            return Optional.empty();
        }
    }


    protected URL stringToURL(String location) throws MalformedURLException {
        if (!location.contains("://")) {
            return new URL("file://"+location);
        } else {
            return new URL(location);
        }
    }


    /**
     * Returns the native Clojure data structure for the model
     * @return Clojure data structure encoding the model
     */
    @Override
    public Object clojureModel() {
        IFn documentModelFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "document-model");
        return documentModelFn.invoke(this.rawModel);
    }

    /**
     * Factory method building the right wrapper Java DocumentModel subclass for the provided Clojure model data structure
     * @param rawModel native Clojure encoded model
     * @return The right DocumentModel
     * @throws InvalidModelException
     */
    public static DocumentModel fromRawModel(Object rawModel) throws InvalidModelException {
        IFn unitKindFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "unit-kind");
        String unitKind = (String) unitKindFn.invoke(rawModel);
        if (Objects.equals(unitKind, "module")) {
            return new Module(rawModel);
        } else if (Objects.equals(unitKind, "fragment")) {
            return new Fragment(rawModel);
        } else if (Objects.equals(unitKind, "document")) {
            return new Document(rawModel);
        } else {
            throw new InvalidModelException(new Exception("Unknown type of document unit " + unitKind));
        }
    }

    public DomainModel findDomainElement(String id) {
        IFn findFn = Clojure.var(Clojure.API_MODELING_FRAMEWORK_CORE, "find-element");
        Object res = findFn.invoke(this.rawModel, (isResolved() ? "domain": "document"), id);
        if (res != null){
            Document doc = (Document) DocumentModel.fromRawModel(res);
            return doc.encodes();
        } else {
            return null;
        }
    }

    public boolean isResolved() {
        return resolved;
    }

    protected void setResolved(boolean resolved) {
        this.resolved = resolved;
    }
}
