/**
 * Created by antoniogarrote on 05/05/2017.
 */
import {Model} from "../Model";

/**
 * AMF Document model that can be used to work with the graph of linked documents generated by the parser.
 */
export class DocumentModel extends Model {

    protected resolved = false;

    constructor(protected rawModel: any) {
        super(rawModel);
    }

    public isResolved(): boolean {
        return this.resolved;
    }

    protected setResolved(isResolved: boolean) {
        this.resolved = isResolved;
    }

    /**
     * Builds a new Model object for the referenced Document
     * @param reference
     * @return
     */
    public modelForReference(reference: URL): DocumentModel {
        const foundRef = this.references()
            .filter(ref => ref === reference)
            .pop();

        if (foundRef == null) {
            throw new Error("Unknown reference " + reference);
        } else {
            return DocumentModel.fromRawModel(Clojure.amf.reference_model(this.rawModel, foundRef));
        }
    }

    /**
     * Returns the list document URIs referenced from the document that has been parsed to generate this model
     * @return An array of URI locations for the remote documents
     */
    public references(): URL[] {
        return Clojure.amf.references(this.rawModel) as URL[];
    }

    /**
     * Returns the file location for the document that has been parsed to generate this model
     * @return URL with the location of the file
     */
    public location(): URL {
        return Clojure.amf.location(this.rawModel);
    }

    public rawText(): undefined | string {
        return Clojure.amf.raw(this.rawModel);
    }

    /**
     * Applies the resolution algorithm and returns a new Model contained the resolved DomainModel
     * @return
     */
    public resolve(): DocumentModel {
        const resolvedRawModel = Clojure.amf.domain_model(this.rawModel);
        const resolvedModel = Clojure.amf.to_model(resolvedRawModel);
        const model = DocumentModel.fromRawModel(resolvedModel);
        if (model != null) {
            model.setResolved(true);
            return model;
        } else {
            throw new Error("Error resolving model, null model computed");
        }
    }

    /**
     * Factory method building the right wrapper Java DocumentModel subclass for the provided Clojure model data structure
     * @param rawModel native Clojure encoded model
     * @return The right DocumentModel
     */
    public static fromRawModel(rawModel: any): DocumentModel {
        if (rawModel == null) {
            throw new Error("Cannot build DocumentModel from null");
        }
        const unitKind = Clojure.amf.unit_kind(rawModel);
        if (unitKind === "document") {
            return new Document(rawModel);
        } else if (unitKind === "module") {
            return new Module(rawModel);
        } else if (unitKind === "fragment") {
            return new Fragment(rawModel);
        } else {
            throw new Error("Unsupported type of unit");
        }
    }

    /**
     * Encoded domain element. It's considered to be the root element of a stand-alone description, not a domain element
     * to be re-used and reference
     * @return DomainElement encoded in the document.
     */
    public encodes(): DomainModel {
        const encodes = Clojure.amf_document.encodes(this.clojureModel());
        return DomainModel.fromRawModel(encodes);
    }

    /**
     * List of domain elements declared in the document to be referenced in the encoded element.
     * They are supposed to be private to the description and not meant to be re-used as in Modules.
     * @return
     */
    public declares(): DomainModel[] {
        return Clojure.cljsMap(
            Clojure.amf_document.declares(this.clojureModel()),
            dec => DomainModel.fromRawModel(dec)
        );
    }

    /**
     * Returns the native Clojure data structure for the model
     * @return Clojure data structure encoding the model
     */
    public clojureModel(): any {
        return Clojure.amf.document_model(this.rawModel);
    }

}

import {Document} from "./Document";
import {Module} from "./Module";
import {Fragment} from "./Fragment";
import {DomainModel} from "../domain/DomainModel";
import {Clojure} from "../../Clojure";